# Get PaintWeb #

You need to get PaintWeb from the SVN repository:
```
svn checkout http://paintweb.googlecode.com/svn/trunk/ paintweb-read-only
```

# Get TinyMCE #

Download [TinyMCE 3](http://tinymce.moxiecode.com) from the official site.

# Install the TinyMCE plugin #

In the PaintWeb tree you can find the [ext/tinymce-plugin](http://code.google.com/p/paintweb/source/browse/trunk/ext/tinymce-plugin/paintweb) folder. There's the **paintweb** folder which you need to copy into the TinyMCE plugins folder - in **jscripts/tiny\_mce/plugins**.

The PaintWeb plugin for TinyMCE allows users to edit in-place any image and to create new images they can draw into.

# Use the PaintWeb plugin #

Once you have the PaintWeb plugin in TinyMCE, you can load it very quickly. You first add the TinyMCE script into your document:

```
<script type="text/javascript"
 src="tinymce/jscripts/tiny_mce/tiny_mce.js"></script>
```

Then you initialize TinyMCE, as usual:

```
<script type="text/javascript"><!--
tinyMCE.init({
  mode: "textareas",
  theme : "advanced",
  // Include the PaintWeb plugin. Put 'paintweb' after
  // the 'contextmenu' plugin if you want context menu
  // integration as well.
  plugins : "contextmenu,paintweb", // ...

  // The PaintWeb configuration object.
  paintweb_config : {
    configFile: "config-example.json",
    // TinyMCE plugin options.
    tinymce: {
      // Tell where PaintWeb is located.
      paintwebFolder: "paintweb/build/",
      imageDataURLfilter: "/path/to/some.php",
      imageSaveDataURL: true,
      overlayButton: true,
      contextMenuItem: true,
      dblclickHandler: true,
      pluginBar: true,
      syncViewportSize: true
    }
  },

  // Theme options
  theme_advanced_buttons1 : "save,newdocument,|,...",

  // The 'paintwebEdit' button.
  theme_advanced_buttons2 : "cut,copy,paste,...,image,paintwebEdit,...",

  // ...
});
// --></script>
```

Basically, you only ask TinyMCE to load the new PaintWeb plugin. You configure the theme to show the `paintwebEdit` button, which allows users to start PaintWeb.

The `paintweb_config` object allows you to change the PaintWeb configuration. The `tinymce` properties allow you to configure how the PaintWeb plugin works in TinyMCE. You have the following options:

  * **paintwebFolder** tells the plugin from where to load PaintWeb.

  * **imageSaveDataURL** tells the plugin to use data URLs when the user saves the image in PaintWeb. The image element in the document has the `src` attribute value updated to contain the data URL generated by the browser when the image is saved.

  * **[imageDataURLfilter](#The_image_data_URL_filter.md)** is an optional property which allows you as a developer to tell the TinyMCE plugin which server-side script to use when the user tries to edit an image which has a data URL as its source. Please see the details below.

  * **overlayButton** tells the plugin to display an "Edit image" button on top of the selected image.

  * **contextMenuItem** tells the plugin to display an "Edit image in PaintWeb" item in the context menu, when the ContextMenu plugin is used in TinyMCE.

  * **dblclickHandler** tells the plugin to register itself as a double-click event handler inside TinyMCE, such that users can double click image elements to invoke PaintWeb.

  * **pluginBar** tells the plugin to display a "plugin bar" at the top of PaintWeb, to provide users with feedback like "you are editing an image from TinyMCE". Additionally, the plugin bar includes two important buttons: Save and Cancel. The former allows the user to save the image and return to TinyMCE, and the latter allows the user to cancel image edits and return to TinyMCE.

  * **syncViewportSize** tells the plugin to synchronize the PaintWeb image viewport dimensions with those of the TinyMCE editor area.

  * **onSubmitUnsaved** allows you to provide a function which is invoked when the form containing the `textarea` is submitted while the user edits an image and has not saved the changes. By default, the TinyMCE plugin cancels the form submission and displays a warning inside the "plugin bar" telling the user he cannot submit the form until the image is saved, or image editing is cancelled. If you want to provide your own warning, perhaps for better integration into your Web application, you can provide a function which is invoked to display the warning however you want. Your function receives three parameters: the DOM event object (form submission), a reference to the TinyMCE editor object instance, and a reference to the PaintWeb object instance.


That's all. Enjoy using PaintWeb in TinyMCE!

# The image data URL filter #

PaintWeb loads images by using the [CanvasRenderingContext2D.drawImage()](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage) method invoked for the DOM image element you provide.

Image elements can have their source attribute pointing to external resources. When the browser renders such external images, the Canvas element is marked as "dirty". This means that PaintWeb can no longer retrieve/read pixels from the Canvas using methods like `context.getImageData()` or `canvas.toDataURL()` - due to security concerns developers are not allowed to "steal" image data from a different domain. This is the reason why PaintWeb does not allow the rendering of external images.

Image elements can also have their source attribute holding a local [data URL](http://en.wikipedia.org/wiki/Data_URI_scheme). Due to bugs, Webkit (Safari/Chrome) and Gecko 1.9.0 (Firefox 3.0) consider such image elements as external resources as well. PaintWeb allows rendering of images with data URLs typically, but in these browsers you will not be able to save the images.

Gecko 1.9.1 (Firefox 3.5) is no longer affected by the bug. Additionally, Webkit has fixed this issue since [rev 48556](http://trac.webkit.org/changeset/48556), but no web browser includes it yet - we have to wait for future Safari and Chrome versions.

To workaround the issue, the TinyMCE plugin must use a server-side script which saves the image on the server and returns the URL pointing to the temporary image file. You can tell the plugin which script to use with the **imageDataURLfilter** property. When the user invokes PaintWeb for an image element which has a data URL and the browser is Webkit-based or Gecko 1.9.0 (or older), then an `XMLHttpRequest` for the script is sent using the `POST` method. The request uses the `application/x-www-form-urlencoded` content type. Your server-side script receives two variables: `url` which is always "-" and `dataURL` which holds the image data URL. Your script is required to parse the data URL, save the image as a binary on the server, and return an URL pointing to the image such that the TinyMCE plugin can load the image. You return the URL using a JSON string: `{"successful": true, "urlNew": "http://example.com/newImage.png"}`.

If all that sounds complex, here's an example PHP script:

```
// The list of allowed image MIME types associated to
// file extensions.
$imgallowedtypes = array(
    'image/png'  => 'png',
    'image/jpeg' => 'jpg'
);

$imgdataurl = &$_POST['dataURL'];

if (empty($imgdataurl)) {
  die('error');
}

// A data URL starts like this:
// data:[<MIME-type>][;charset="<encoding>"][;base64],<data>

// Here we find the comma delimiter.
$comma = strpos($imgdataurl, ',');
if (!$comma) {
  die('error');
}

$imginfo = substr($imgdataurl, 0, $comma);
if (empty($imginfo) || !isset($imgdataurl{($comma+2)})) {
  die('error');
}

// Split by ':' to find the 'data' prefix and the rest of
// the info.
$imginfo = explode(':', $imginfo);

// The array must have exactly two elements and the
// second element must not be empty.
if (count($imginfo) !== 2 || $imginfo[0] !== 'data' ||
    empty($imginfo[1])) {
  die('error');
}

// The MIME type must be given and it must be base64-encoded.
$imginfo = explode(';', $imginfo[1]);

if (count($imginfo) < 2 ||
    !array_key_exists($imginfo[0], $imgallowedtypes) ||
    ($imginfo[1] !== 'base64' && $imginfo[2] !== 'base64')) {
  die('error');
}

$imgdest = 'tmpImages/' . sha1($imgdataurl) . '.' .
            $imgallowedtypes[$imginfo[0]];
$imgdataurl = substr($imgdataurl, $comma + 1);

if (!file_put_contents($imgdest, base64_decode($imgdataurl))) {
  die('error');
}

echo json_encode(array('successful' => true, 'urlNew' => $imgdest));
```

Obviously, you **must** add security checks such that not everyone can save images on your server.